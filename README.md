# REFLECTION

1. What are the key differences between unary, server streaming, and bi-directional streaming RPC (Remote Procedure Call) methods, and in what scenarios would each be most suitable? <br>
    Unary, server streaming, dan bi-directional streaming RPC merupakan 3 pattern komunikasi yang digunakan di RPC. Pada Unary RPC, client mengirim satu request kepada server dan menerima satu response. Unary RPC cocok untuk skenario dimana client butuh membuat sebuah request dan berekspektasi mendapat sebuah response yang simple seperti request user authentication. 
    Pada Server Streaming RPC, client mengirim sebuah request pada server, namun server merespons dengan stream of messages. Server Streaming RPC ini cocok untuk kasus dimana server butuh mengirim data yang banyak pada client secara sequential seperti streaming multimedia content. 
    Pada Bi-directional Streaming RPC, baik client maupun server saling mengirim stream of messages ke satu sama lain secara concurrent. Ini cocok untuk skenario dimana dibutuhkan komunikasi real-time antara client dan juga server seperti collaborative editing. <br>

2. What are the potential security considerations involved in implementing a gRPC service in Rust, particularly regarding authentication, authorization, and data encryption? <br>
    Untuk authentication, dapat menggunakan TLS (Transport Layer Security) untuk memastikan komunikasi antar client dan server dienkripsi. Untuk authorization dapat mengimplementasi RBAC (role-based access control) untuk menerapkan access policies dan melimitasi tindakan yang dapat digunakan setiap pengguna atau server. Untuk data encryption, menggunakan algoritma yang kuat seperti AES dan RSA.  <br>

3. What are the potential challenges or issues that may arise when handling bidirectional streaming in Rust gRPC, especially in scenarios like chat applications? <br>
    Kesulitan yang berpotensi akan muncul pada skenario aplikasi chat adalah concurrency dan managment program. Karena server perlu dapat mengatasi stream of messages yang dikirim secara concurrent agar flow of messages dapat teregulasi. Selain itu, harus dapat mengatasi error yang terjadi pada continuous data flow. Pada rust, walau sistem ownership-nya baik memory safety, namun kompleksitas program tersebut akan bertambah dalam management data streams. <br>

4. What are the advantages and disadvantages of using the tokio_stream::wrappers::ReceiverStream for streaming responses in Rust gRPC services?
    Keuntungannya adalah ReceiverStream terintegrasi secara seamless dengan Tokio, sehingga cocok untuk Riust gRCP services. kemudian, ReceiverStream memfasilitasi asynchronous stream interface, agar dapat mengatasi streaming responses secara asinkronus tanpa memblok eksekusi task lainnya. Selain itu, ReceiverStream dapat digunakan untuk tipe apapun yang mengimplement Stream, seperti channels, futures, iterators, dan stream async lainnya.
    Kerugiannya adalah pemrograman dengan Rust terutama Tokio menghasilkan program yang kompleks dan sulit untuk dipahami. Selain itu, adanya potensi terjadi performance overhead karena context switching, task scheduling, dll. <br>

5. In what ways could the Rust gRPC code be structured to facilitate code reuse and modularity, promoting maintainability and extensibility over time? <br>
    Terdapat beberapa strategi yang dapat dilakukan yang memfasilitasi code reuse dan modularity, mempromosikan maintainability dan extensibility. Mendefinisikan tipe service dan messages berdasarkan fungsionalitas pada modul atau file terpisah agar mempermudah untuk reuse code dan extend komponen individual. <br>

6. In the MyPaymentService implementation, what additional steps might be necessary to handle more complex payment processing logic? <br>
    Langkah tambahan yang dapat diambil ialah error management pada MyPaymentService. Selain itu, dapat mengimplementasi streaming RPC selain unary agar pengiriman data dapat lebih kompleks dan mengurangi overhead. <br>

7. What impact does the adoption of gRPC as a communication protocol have on the overall architecture and design of distributed systems, particularly in terms of interoperability with other technologies and platforms? <br>
    gRPC bersifat language-agnostic dan dapat suport berbagai programming language. gRPC menaikan efiseinsi dan performance dengan support untuk binary serialization dan HTTP/2transport. Selain itu, gRPC bergantung pada Protocol Buffers untuk mendefinisikan service contracts dan format messages. gRPC gateways atau proxies dapat digunakan untuk menjembatani gap antara gRPC-based services dan client yang berkomunikasi via HTTP/REST. <br>
8. What are the advantages and disadvantages of using HTTP/2, the underlying protocol for gRPC, compared to HTTP/1.1 or HTTP/1.1 with WebSocket for REST APIs? <br>
    Keuntungannya HTTP/2 secara general memberikan performance yang lebih baik. latency nya lebih rendah. dan efisiensi lebih tinggi dibandingkan HTTP/1.1 untuk skenario dengan concurrent request yang banyak atau header size yang besar. Fitur HTTP/2 seperti multiplexing, header compression, dan server push membuatnya cocok untuk web aplikasi modern dan API yang membutuhkan performance yang tinggi, latency rendah, dan penggunaan network resources yang efisien. 
    Kerugiannya adalah HTTP/2 lebih kompleks dalam konteks protokol implementasi dan debugging. Selain itu, tidak semua client dan server dapat mendukung HTTP/2. Terakhir, fitur-fitur multiplexing dan header compression membutuhkan server resources yang lebih. <br>
9. How does the request-response model of REST APIs contrast with the bidirectional streaming capabilities of gRPC in terms of real-time communication and responsiveness? <br>
    REST API bergantung pada request-response model untuk komunikasi yang dapat menyebabkan latency dan overhead dalam skenario real-time. Kapabilitas Bidirectional streaming dari gRPC menyediakan channel komunikasi yang lebih responsif dan efisien untuk aplikasi yang membutuhkan latency rendah, real-time updates, dan biderictional data exchange. <br>
10. What are the implications of the schema-based approach of gRPC, using Protocol Buffers, compared to the more flexible, schema-less nature of JSON in REST API payloads? <br>
    Pada Schema-based approach dari gRPC dengan protocol buffers, protocol buffer tersebut mendefinisikan skema yang strict untuk message formats dan service contracts menggunakan interface definition language (IDL) yang language-agnostic. Schema-based approach menyediakan strong typing, versioning, dan kapabilitas validasi, untuk memastikan konsistensi dan kompatibilitas dari services dan clients. Protocol Buffers juga support code generation untuk client dan server stubs pada programming language beragam agar mengurangi kemungkinan error yang integral. Evolusi schema dan backward compatibility secara explisit di-support pada Protocol Buffers agar service dapat berkembang tanpa merusak client yang sudah ada.
    Sementara itu, pada Flexible, Scherma-less natur dari JSON dan REST API Payloads terimplikasi tidak ada constraints yang strict pada struktur maupun types. JSON juga di-support pada bahasa pemrograman dan platform yang beragam, membuatnya accessible dan interoperable untuk client dan services yang luas. 
